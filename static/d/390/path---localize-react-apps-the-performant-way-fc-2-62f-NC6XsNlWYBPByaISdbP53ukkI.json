{"data":{"ghostPost":{"id":"Ghost__Post__5c9a41371046a4000156bcf3","title":"Localize React Apps the Performant Way","slug":"localize-react-apps-the-performant-way","featured":false,"feature_image":"http://localhost:2368/content/images/2019/03/roman-kraft-136249-unsplash-1.jpg","excerpt":"There are so many possibilities when you want to localize your application with\nyour React application. I believe that localization is difficult because it\nrequires excellence in several pieces of a stack at the same time. You have to\nhave a working pipeline that can take string resources that would get\ntranslated. Then, you have to have a way to load these strings onto your page or\napplication. Finally, you have to have a way to take these strings and inject\nthem into the components inside your","custom_excerpt":null,"created_at_pretty":"26 March, 2019","published_at_pretty":"26 March, 2019","updated_at_pretty":"26 March, 2019","created_at":"2019-03-26T15:11:51.000+00:00","published_at":"2019-03-26T17:55:16.000+00:00","updated_at":"2019-03-26T20:20:49.000+00:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Ken Chau","slug":"ken","bio":null,"profile_image":"//www.gravatar.com/avatar/45fc02e659e008e7b53c0b8ee8dd71a1?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Ken Chau","slug":"ken","bio":null,"profile_image":"//www.gravatar.com/avatar/45fc02e659e008e7b53c0b8ee8dd71a1?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null},"primary_tag":null,"tags":[],"plaintext":"There are so many possibilities when you want to localize your application with\nyour React application. I believe that localization is difficult because it\nrequires excellence in several pieces of a stack at the same time. You have to\nhave a working pipeline that can take string resources that would get\ntranslated. Then, you have to have a way to load these strings onto your page or\napplication. Finally, you have to have a way to take these strings and inject\nthem into the components inside your application. As you can see, you can choose\njust about any tech to help you accomplish these goals. I am documenting a\nparticular set of stack that I believe helps you achieve this in the most\nperformant way with tools that you're already probably using.\n\nTranslation Pipeline\nAt work, we actually have a wonderful team that is dedicated to this task.\nThere's a growing team that has built a simple Azure DevOps\n[https://devops.azure.com]  task we would just inject into some pipeline that\ngets run nightly. We have a translation-as-a-service that we can rely on to have\nfresh strings localized for us every night.\n\nNot everyone is as fortunate that has something they can use from their own\ncompany. Given that, I'll suggest a pattern here as the first step. Do a search\nfor \"localization as a service\" and look for a partner that can help inject a\nstep in your CI pipeline of choice. Set up a nightly job to refresh your\napplication's localized strings as JSON like this:\n\n{\n  \"HELLO_NAME\": \"Hello {name}!\",\n  \"CLICK_ME\": \"Click me\"\n}\n\n\nRendering Localized Strings\nReact is a large ecosystem. So then the paradox of choice is real when finding\nsupplemental libraries for React. Conventional wisdom is to find the most\npopular packages from npmjs.org. So given this, I first looked at react-intl  to\nhelp me inject localized strings into my application. The issue here is that \nreact-intl  uses higher order components all over the place. One of the explicit\ngoals (as I heard it from ReactConf 2018) of React hooks is to do away with\ndepth of the component tree caused by the higher order components. Higher order\ncomponent, or HOC, is a neat idea until the consumer needed to access the ref to\nthe original wrapped component. When all your components that use localized\nstrings are wrapped in HOCs, your application start to look like a sideways\nmountain. (aside: go look at your component tree in React DevTool to see if\nyou're suffering from HOC-itis)\n\nEnter react-intl-universal [https://github.com/alibaba/react-intl-universal].\nThe Alibaba Group created this library to get around the HOC issues of \nreact-intl. On top of this, there are times where strings are needed from\noutside of the component's render()  method. It takes 2 steps to place strings\ninside your components. \n\nFirst you have to initialize the locale data. Note that the data can be\npreloaded from a server or can be retrieved at runtime. The choice is yours. For\nthe most optimal case, we definitely would have the server preload strings right\nin the app as it is being loaded.\n\nServer Preloaded\nLet's imagine for a moment that we have all the data in this format from a\nserver loaded .json  file. Pretend that ./locales/en-US.json  has the same\ncontent as the example above.\n\n// locale data\nconst locales = {\n  \"en-US\": require('./locales/en-US.json'),\n  \"zh-CN\": require('./locales/zh-CN.json'),\n};\n\n\nThen, we initialize the react-intl-universal  library inside a \ncomponentDidMount()  call. And we'll use the localized string inside the \nrender()  method with the .get()  function: \n\nclass App extends Component {\n  state = { isLoading: false }\n  componentDidMount() {\n    this.loadLocales();\n  }\n\n  async loadLocales() {\n    await intl.init({\n      currentLocale: 'en-US',\n      locales,\n    });\n    this.setState({ isLoading: true });\n  }\n\n  render() {\n    return (\n      !this.state.isLoading &&\n      <div>\n        {intl.get('HELLO_NAME', {name: 'world'})}\n      </div>\n    );\n  }\n\n}\n\n\nLoading Localized Strings\nThis is where it gets interesting. Some codebases I've seen had been using","html":"<p>There are so many possibilities when you want to localize your application with your React application. I believe that localization is difficult because it requires excellence in several pieces of a stack at the same time. You have to have a working pipeline that can take string resources that would get translated. Then, you have to have a way to load these strings onto your page or application. Finally, you have to have a way to take these strings and inject them into the components inside your application. As you can see, you can choose just about any tech to help you accomplish these goals. I am documenting a particular set of stack that I believe helps you achieve this in the most performant way with tools that you're already probably using.</p><h2 id=\"translation-pipeline\">Translation Pipeline</h2><p>At work, we actually have a wonderful team that is dedicated to this task. There's a growing team that has built a simple <a href=\"https://devops.azure.com\">Azure DevOps</a> task we would just inject into some pipeline that gets run nightly. We have a translation-as-a-service that we can rely on to have fresh strings localized for us every night.</p><p>Not everyone is as fortunate that has something they can use from their own company. Given that, I'll suggest a pattern here as the first step. Do a search for \"localization as a service\" and look for a partner that can help inject a step in your CI pipeline of choice. Set up a nightly job to refresh your application's localized strings as JSON like this:</p><!--kg-card-begin: markdown--><pre><code class=\"language-json\">{\n  &quot;HELLO_NAME&quot;: &quot;Hello {name}!&quot;,\n  &quot;CLICK_ME&quot;: &quot;Click me&quot;\n}\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"rendering-localized-strings\">Rendering Localized Strings</h2><p>React is a large ecosystem. So then the paradox of choice is real when finding supplemental libraries for React. Conventional wisdom is to find the most popular packages from npmjs.org. So given this, I first looked at <code>react-intl</code> to help me inject localized strings into my application. The issue here is that <code>react-intl</code> uses higher order components all over the place. One of the explicit goals (as I heard it from ReactConf 2018) of React hooks is to do away with depth of the component tree caused by the higher order components. Higher order component, or HOC, is a neat idea until the consumer needed to access the ref to the original wrapped component. When all your components that use localized strings are wrapped in HOCs, your application start to look like a sideways mountain. (aside: go look at your component tree in React DevTool to see if you're suffering from HOC-itis)</p><p>Enter <code><a href=\"https://github.com/alibaba/react-intl-universal\">react-intl-universal</a></code>. The Alibaba Group created this library to get around the HOC issues of <code>react-intl</code>. On top of this, there are times where strings are needed from outside of the component's <code>render()</code> method. It takes 2 steps to place strings inside your components. </p><p>First you have to initialize the locale data. Note that the data can be preloaded from a server or can be retrieved at runtime. The choice is yours. For the most optimal case, we definitely would have the server preload strings right in the app as it is being loaded.</p><h3 id=\"server-preloaded\">Server Preloaded</h3><p>Let's imagine for a moment that we have all the data in this format from a server loaded <code>.json</code> file. Pretend that <code>./locales/en-US.json</code> has the same content as the example above.</p><!--kg-card-begin: markdown--><pre><code class=\"language-jsx\">// locale data\nconst locales = {\n  &quot;en-US&quot;: require('./locales/en-US.json'),\n  &quot;zh-CN&quot;: require('./locales/zh-CN.json'),\n};\n</code></pre>\n<!--kg-card-end: markdown--><p>Then, we initialize the <code>react-intl-universal</code> library inside a <code>componentDidMount()</code> call. And we'll use the localized string inside the <code>render()</code> method with the <code>.get()</code> function: </p><!--kg-card-begin: markdown--><pre><code class=\"language-jsx\">class App extends Component {\n  state = { isLoading: false }\n  componentDidMount() {\n    this.loadLocales();\n  }\n\n  async loadLocales() {\n    await intl.init({\n      currentLocale: 'en-US',\n      locales,\n    });\n    this.setState({ isLoading: true });\n  }\n\n  render() {\n    return (\n      !this.state.isLoading &amp;&amp;\n      &lt;div&gt;\n        {intl.get('HELLO_NAME', {name: 'world'})}\n      &lt;/div&gt;\n    );\n  }\n\n}\n</code></pre>\n<!--kg-card-end: markdown--><h3 id=\"loading-localized-strings\">Loading Localized Strings</h3><p>This is where it gets interesting. Some codebases I've seen had been using </p>","url":"http://localhost:2368/localize-react-apps-the-performant-way/","uuid":"86d08ddb-d015-45d6-8f74-9a5affb6b63e","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c9a41371046a4000156bcf3"}},"pageContext":{"slug":"localize-react-apps-the-performant-way"}}