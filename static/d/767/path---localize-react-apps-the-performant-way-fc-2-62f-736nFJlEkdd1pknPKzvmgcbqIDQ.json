{"data":{"ghostPost":{"id":"Ghost__Post__5c9a41371046a4000156bcf3","title":"Localize React without Bloating the Bundle","slug":"localize-react-apps-the-performant-way","featured":false,"feature_image":"http://localhost:2368/content/images/2019/03/roman-kraft-136249-unsplash-1.jpg","excerpt":"There are so many possibilities when you want to localize your application with\nyour React application. I believe that localization is difficult because it\nrequires excellence in several pieces of a stack at the same time. You have to\nhave a working pipeline that can take string resources that would get\ntranslated. Then, you have to have a way to load these strings onto your page or\napplication. Finally, you have to have a way to take these strings and inject\nthem into the components inside your","custom_excerpt":null,"created_at_pretty":"26 March, 2019","published_at_pretty":"26 March, 2019","updated_at_pretty":"26 March, 2019","created_at":"2019-03-26T15:11:51.000+00:00","published_at":"2019-03-26T17:55:16.000+00:00","updated_at":"2019-03-26T22:21:18.000+00:00","meta_title":null,"meta_description":null,"og_description":null,"og_image":null,"og_title":null,"twitter_description":null,"twitter_image":null,"twitter_title":null,"authors":[{"name":"Ken Chau","slug":"ken","bio":null,"profile_image":"//www.gravatar.com/avatar/45fc02e659e008e7b53c0b8ee8dd71a1?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null}],"primary_author":{"name":"Ken Chau","slug":"ken","bio":null,"profile_image":"//www.gravatar.com/avatar/45fc02e659e008e7b53c0b8ee8dd71a1?s=250&d=mm&r=x","twitter":null,"facebook":null,"website":null},"primary_tag":null,"tags":[],"plaintext":"There are so many possibilities when you want to localize your application with\nyour React application. I believe that localization is difficult because it\nrequires excellence in several pieces of a stack at the same time. You have to\nhave a working pipeline that can take string resources that would get\ntranslated. Then, you have to have a way to load these strings onto your page or\napplication. Finally, you have to have a way to take these strings and inject\nthem into the components inside your application. As you can see, you can choose\njust about any tech to help you accomplish these goals. I am documenting a\nparticular set of stack that I believe helps you achieve this in the most\nperformant way with tools that you're already probably using.\n\nTranslation Pipeline\nAt work [https://github.com/officedev/office-ui-fabric-react], we have a\ntranslation-as-a-service API that we rely on to refresh localized strings for us\nevery night. There's a growing team that has built a simple Azure DevOps\n[https://devops.azure.com]  task we add as a step in one of our pipelines which\nruns nightly. \n\nNot everyone is as fortunate that has something they can use from their own\ncompany. Given that, I'll suggest a pattern here as the first step. Do a search\nfor \"localization as a service\" and look for a vendor that can help add a step\nin your CI pipeline of choice. Set up a nightly job to refresh your\napplication's localized strings as JSON like this:\n\n{\n  \"HELLO_NAME\": \"Hello {name}!\",\n  \"CLICK_ME\": \"Click me\"\n}\n\n\nRendering Localized Strings\nReact is a large ecosystem. So then the paradox of choice is real when finding\nsupplemental libraries for React. Conventional wisdom is to find the most\npopular packages from npmjs.org. So given this, I first looked at react-intl  to\nhelp me inject localized strings into my application. The issue here is that \nreact-intl  uses higher order components all over the place. One of the explicit\ngoals (as I heard it from ReactConf 2018) of React hooks is to do away with\ndepth of the component tree caused by the higher order components. Higher order\ncomponent, or HOC, is a neat idea until the consumer needed to access the ref to\nthe original wrapped component. When all your components that use localized\nstrings are wrapped in HOCs, your application start to look like a sideways\nmountain. (aside: go look at your component tree in React DevTool to see if\nyou're suffering from HOC-itis)\n\nEnter react-intl-universal [https://github.com/alibaba/react-intl-universal].\nThe Alibaba Group created this library to get around the HOC issues of \nreact-intl. On top of this, there are times where strings are needed from\noutside of the component's render()  method. It takes 2 steps to place strings\ninside your components. \n\nFirst you have to initialize the locale data. Note that the data can be\npreloaded from a server or can be retrieved at runtime. The choice is yours. For\nthe most optimal case, we definitely would have the server preload strings right\nin the app as it is being loaded.\n\nLet's pretend that ./locales/en-US.json  has the same content as the example\nabove.\n\n// locale data\nconst locales = {\n  \"en-US\": require('./locales/en-US.json'),\n  \"zh-CN\": require('./locales/zh-CN.json'),\n};\n\n\nThen, we initialize the react-intl-universal  library inside a \ncomponentDidMount()  call. And we'll use the localized string inside the \nrender()  method with the .get()  function: \n\nimport intl from 'react-intl-universal'; \n\nclass App extends Component {\n  state = { isLoading: false }\n  componentDidMount() {\n    this.loadLocales();\n  }\n\n  async loadLocales() {\n    await intl.init({\n      currentLocale: 'en-US',\n      locales,\n    });\n    this.setState({ isLoading: true });\n  }\n\n  render() {\n    return (\n      !this.state.isLoading &&\n      <div>\n        {intl.get('HELLO_NAME', {name: 'world'})}\n      </div>\n    );\n  }\n\n}\n\n\nNote that the init()  call returns a Promise. This means that we can use the\nasync / await syntax to write our string load code. Once this is added, we look\nat the way we retrieve the strings by key. For that, we use the get(). Get takes\nin two parameters: the key and some object. Sometimes the strings have slots\nthat can be replaced by the object values.\n\nLoading Localized Strings\nThis is where it gets interesting. So far, we've assumed that we had the locale\ndata all upfront. This means that all the localized strings would had been\nloaded inside a bundle or onto the page somehow. Loading all the language\nstrings in one go can only be feasible if the app barely contain any text. If\nwe're using Webpack, we should take advantage of a feature that I recently came\nto know. We all have seen the dynamic import()  syntax:\n\nconst SomeModule = import('some-module');\n\n\nBut, have you seen what Webpack can do with something like this?\n\nconst getLocale = (locale) => import(`./locales/${locale}.json`);\n\n\nBased on the .json  files it finds inside ./locales, Webpack is smart enough to\ngenerate chunks for dynamic loading! That means your main bundle will not incur\nthe weight of the entire library of localized strings. Putting all these\nconcepts together, I've created a repo to demonstrate concepts from this post:\n\nhttps://github.com/kenotron/react-intl-example\n\nI'll go over some of the points from that repo. First, I created a HOC that you\nplace at the ROOT of the application. Don't worry! It is only one HOC for the\nentire app. It is called LocaleComponent  - I'm keeping this strange little name\nuntil React.createResource()  becomes a thing maybe in the future.\n\nconst getLocale = (locale: string) => import(`./locale/${locale}.json`);\n\nclass LocaleComponent extends React.Component {\n  state = { isLoading: true };\n  \n  async loadLocales() { \n    const locales = await getLocale('en');\n    const currentLocale = 'en';\n    await intl.init({ currentLocale, locales });\n    this.setState({ isLoading: false });\n  }\n  \n  render() {\n    return !this.state.isLoading ? <>this.props.children</> : null;\n  }\n}","html":"<p>There are so many possibilities when you want to localize your application with your React application. I believe that localization is difficult because it requires excellence in several pieces of a stack at the same time. You have to have a working pipeline that can take string resources that would get translated. Then, you have to have a way to load these strings onto your page or application. Finally, you have to have a way to take these strings and inject them into the components inside your application. As you can see, you can choose just about any tech to help you accomplish these goals. I am documenting a particular set of stack that I believe helps you achieve this in the most performant way with tools that you're already probably using.</p><h2 id=\"translation-pipeline\">Translation Pipeline</h2><p>At <a href=\"https://github.com/officedev/office-ui-fabric-react\">work</a>, we have a translation-as-a-service API that we rely on to refresh localized strings for us every night. There's a growing team that has built a simple <a href=\"https://devops.azure.com\">Azure DevOps</a> task we add as a step in one of our pipelines which runs nightly. </p><p>Not everyone is as fortunate that has something they can use from their own company. Given that, I'll suggest a pattern here as the first step. Do a search for \"localization as a service\" and look for a vendor that can help add a step in your CI pipeline of choice. Set up a nightly job to refresh your application's localized strings as JSON like this:</p><!--kg-card-begin: markdown--><pre><code class=\"language-json\">{\n  &quot;HELLO_NAME&quot;: &quot;Hello {name}!&quot;,\n  &quot;CLICK_ME&quot;: &quot;Click me&quot;\n}\n</code></pre>\n<!--kg-card-end: markdown--><h2 id=\"rendering-localized-strings\">Rendering Localized Strings</h2><p>React is a large ecosystem. So then the paradox of choice is real when finding supplemental libraries for React. Conventional wisdom is to find the most popular packages from npmjs.org. So given this, I first looked at <code>react-intl</code> to help me inject localized strings into my application. The issue here is that <code>react-intl</code> uses higher order components all over the place. One of the explicit goals (as I heard it from ReactConf 2018) of React hooks is to do away with depth of the component tree caused by the higher order components. Higher order component, or HOC, is a neat idea until the consumer needed to access the ref to the original wrapped component. When all your components that use localized strings are wrapped in HOCs, your application start to look like a sideways mountain. (aside: go look at your component tree in React DevTool to see if you're suffering from HOC-itis)</p><p>Enter <code><a href=\"https://github.com/alibaba/react-intl-universal\">react-intl-universal</a></code>. The Alibaba Group created this library to get around the HOC issues of <code>react-intl</code>. On top of this, there are times where strings are needed from outside of the component's <code>render()</code> method. It takes 2 steps to place strings inside your components. </p><p>First you have to initialize the locale data. Note that the data can be preloaded from a server or can be retrieved at runtime. The choice is yours. For the most optimal case, we definitely would have the server preload strings right in the app as it is being loaded.</p><p>Let's pretend that <code>./locales/en-US.json</code> has the same content as the example above.</p><!--kg-card-begin: markdown--><pre><code class=\"language-jsx\">// locale data\nconst locales = {\n  &quot;en-US&quot;: require('./locales/en-US.json'),\n  &quot;zh-CN&quot;: require('./locales/zh-CN.json'),\n};\n</code></pre>\n<!--kg-card-end: markdown--><p>Then, we initialize the <code>react-intl-universal</code> library inside a <code>componentDidMount()</code> call. And we'll use the localized string inside the <code>render()</code> method with the <code>.get()</code> function: </p><!--kg-card-begin: markdown--><pre><code class=\"language-jsx\">import intl from 'react-intl-universal'; \n\nclass App extends Component {\n  state = { isLoading: false }\n  componentDidMount() {\n    this.loadLocales();\n  }\n\n  async loadLocales() {\n    await intl.init({\n      currentLocale: 'en-US',\n      locales,\n    });\n    this.setState({ isLoading: true });\n  }\n\n  render() {\n    return (\n      !this.state.isLoading &amp;&amp;\n      &lt;div&gt;\n        {intl.get('HELLO_NAME', {name: 'world'})}\n      &lt;/div&gt;\n    );\n  }\n\n}\n</code></pre>\n<!--kg-card-end: markdown--><p>Note that the <code>init()</code> call returns a <code>Promise</code>. This means that we can use the async / await syntax to write our string load code. Once this is added, we look at the way we retrieve the strings by key. For that, we use the <code>get()</code>. Get takes in two parameters: the key and some object. Sometimes the strings have slots that can be replaced by the object values.</p><h3 id=\"loading-localized-strings\">Loading Localized Strings</h3><p>This is where it gets interesting. So far, we've assumed that we had the locale data all upfront. This means that all the localized strings would had been loaded inside a bundle or onto the page somehow. Loading all the language strings in one go can only be feasible if the app barely contain any text. If we're using Webpack, we should take advantage of a feature that I recently came to know. We all have seen the dynamic <code>import()</code> syntax:</p><!--kg-card-begin: markdown--><pre><code class=\"language-jx\">const SomeModule = import('some-module');\n</code></pre>\n<!--kg-card-end: markdown--><p>But, have you seen what Webpack can do with something like this?</p><!--kg-card-begin: markdown--><pre><code class=\"language-js\">const getLocale = (locale) =&gt; import(`./locales/${locale}.json`);\n</code></pre>\n<!--kg-card-end: markdown--><p>Based on the <code>.json</code> files it finds inside <code>./locales</code>, Webpack is smart enough to generate chunks for dynamic loading! That means your main bundle will not incur the weight of the entire library of localized strings. Putting all these concepts together, I've created a repo to demonstrate concepts from this post:</p><p><a href=\"https://github.com/kenotron/react-intl-example\">https://github.com/kenotron/react-intl-example</a></p><p>I'll go over some of the points from that repo. First, I created a HOC that you place at the ROOT of the application. Don't worry! It is only one HOC for the entire app. It is called <code>LocaleComponent</code> - I'm keeping this strange little name until <code>React.createResource()</code> becomes a thing maybe in the future.</p><!--kg-card-begin: markdown--><pre><code class=\"language-jsx\">const getLocale = (locale: string) =&gt; import(`./locale/${locale}.json`);\n\nclass LocaleComponent extends React.Component {\n  state = { isLoading: true };\n  \n  async loadLocales() { \n    const locales = await getLocale('en');\n    const currentLocale = 'en';\n    await intl.init({ currentLocale, locales });\n    this.setState({ isLoading: false });\n  }\n  \n  render() {\n    return !this.state.isLoading ? &lt;&gt;this.props.children&lt;/&gt; : null;\n  }\n}\n</code></pre>\n<!--kg-card-end: markdown-->","url":"http://localhost:2368/localize-react-apps-the-performant-way/","uuid":"86d08ddb-d015-45d6-8f74-9a5affb6b63e","page":false,"codeinjection_foot":null,"codeinjection_head":null,"comment_id":"5c9a41371046a4000156bcf3"}},"pageContext":{"slug":"localize-react-apps-the-performant-way"}}